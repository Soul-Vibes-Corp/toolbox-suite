<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Desert Defense</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        :root {
            --bg-color: #3d352a;
            --path-color: #8c7853;
            --text-color: #aaffaa;
            --glow-primary: #aaffaa;
            --glow-secondary: #ff8c00;
            --ui-bg: rgba(20, 30, 20, 0.8);
        }
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
        }
        body {
            font-family: 'Orbitron', sans-serif;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            padding: 10px;
        }
        canvas {
            background: linear-gradient(to bottom, #7a6a4f, #5a4a2f);
            border-radius: 15px;
            box-shadow: 0 0 20px var(--glow-primary);
            border: 2px solid var(--glow-primary);
            max-width: 100%;
            max-height: calc(100% - 140px); 
            box-sizing: border-box;
        }
        .ui-panel {
            width: 100%;
            max-width: 1000px; 
            background-color: var(--ui-bg);
            backdrop-filter: blur(5px);
            border: 2px solid var(--glow-secondary);
            border-radius: 15px;
            padding: 10px;
            margin-top: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 0 15px var(--glow-secondary);
        }
        .tower-select, .game-stats, .game-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .tower-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(0,0,0,0.4);
            border: 2px solid var(--glow-primary);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 5px;
            box-sizing: border-box;
        }
        .tower-btn.selected, .tower-btn:hover {
            transform: scale(1.1);
            border-color: var(--glow-secondary);
            box-shadow: 0 0 10px var(--glow-secondary);
        }
        .tower-btn .cost {
            font-size: 0.8rem;
            color: #ffd700;
        }
        .stat-display {
            font-size: 1rem;
            text-shadow: 0 0 5px var(--glow-primary);
        }
        .action-btn {
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-color);
            background: linear-gradient(45deg, #5a4a2f, #8c7853);
            border: 2px solid var(--glow-primary);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px var(--glow-primary);
        }
        .action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--glow-secondary);
        }
        .action-btn:disabled {
            background: #444;
            cursor: not-allowed;
            box-shadow: none;
            color: #888;
            border-color: #666;
        }
        .modal {
            display: flex; position: fixed; z-index: 100; left: 0; top: 0;
            width: 100%; height: 100%; background-color: rgba(20, 30, 20, 0.9);
            justify-content: center; align-items: center; visibility: hidden; opacity: 0;
            transition: visibility 0s 0.5s, opacity 0.5s ease;
        }
        .modal.visible { visibility: visible; opacity: 1; transition: visibility 0s, opacity 0.5s ease; }
        .modal-content {
            background: var(--ui-bg); padding: 2rem 4rem;
            border: 2px solid var(--glow-primary); border-radius: 1rem;
            text-align: center; box-shadow: 0 0 30px var(--glow-primary);
        }
        .modal-title { font-size: 3rem; margin-bottom: 1rem; text-shadow: 0 0 10px var(--glow-primary); color: #ff4c4c; }
        .modal-text { font-size: 1.5rem; margin-bottom: 1rem; }
        .high-score { color: var(--glow-secondary); }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-panel">
        <div class="tower-select">
            <button class="tower-btn" data-tower-type="turret">
                <svg width="30" height="30" viewBox="0 0 100 100">
                    <rect x="20" y="20" width="60" height="60" fill="#6B8E23" />
                    <rect x="40" y="5" width="20" height="50" fill="#556B2F" />
                    <circle cx="50" cy="50" r="15" fill="#465925" />
                </svg>
                <span class="cost">$100</span>
            </button>
            <button class="tower-btn" data-tower-type="rocket">
                 <svg width="30" height="30" viewBox="0 0 100 100">
                    <rect x="20" y="20" width="60" height="60" fill="#6B8E23" />
                    <rect x="30" y="10" width="40" height="40" fill="#556B2F" />
                    <circle cx="50" cy="30" r="10" fill="#FF4500" />
                </svg>
                <span class="cost">$150</span>
            </button>
        </div>
        <div class="game-stats">
            <div class="stat-display">Score: <span id="score">0</span></div>
            <div class="stat-display">Funds: $<span id="funds">300</span></div>
            <div class="stat-display">Base HP: <span id="lives">20</span></div>
            <div class="stat-display">Wave: <span id="wave">0</span></div>
        </div>
        <div class="game-controls">
            <button id="startWaveBtn" class="action-btn">Start Wave</button>
        </div>
    </div>
</div>

<div id="gameOverModal" class="modal">
    <div class="modal-content">
        <h2 class="modal-title">BASE OVERRUN</h2>
        <p class="modal-text">You survived <span id="wavesSurvived">0</span> waves.</p>
        <p class="modal-text">Final Score: <span id="finalScore">0</span></p>
        <p class="modal-text high-score">High Score: <span id="highScore">0</span></p>
        <button id="redeployBtn" class="action-btn">REDEPLOY</button>
    </div>
</div>

<script type="module">
    import { getAuth, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.7.3/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.7.3/firebase-firestore.js";
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.7.3/firebase-app.js";

    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const scoreEl = document.getElementById('score');
        const fundsEl = document.getElementById('funds');
        const livesEl = document.getElementById('lives');
        const waveEl = document.getElementById('wave');
        const startWaveBtn = document.getElementById('startWaveBtn');
        const towerButtons = document.querySelectorAll('.tower-btn');
        const gameOverModal = document.getElementById('gameOverModal');
        const wavesSurvivedEl = document.getElementById('wavesSurvived');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreEl = document.getElementById('highScore');
        const redeployBtn = document.getElementById('redeployBtn');
        
        let TILE_SIZE;
        let funds, lives, wave, score, highScore = 0;
        let selectedTowerType = null, gameRunning = true, waveBonusAwarded = true;

        let userId, isAuthReady;
        const towers = [], enemies = [], projectiles = [];
        
        const path = [
            {x: 0, y: 5}, {x: 3, y: 5}, {x: 3, y: 2}, {x: 7, y: 2}, 
            {x: 7, y: 8}, {x: 12, y: 8}, {x: 12, y: 4}, {x: 15, y: 4}, {x: 15, y: 10}, {x: 20, y: 10}
        ];

        const towerSpots = [
            {x: 1, y: 3}, {x: 3, y: 3}, {x: 5, y: 0}, {x: 5, y: 3}, {x: 7, y: 4},
            {x: 9, y: 6}, {x: 10, y: 2}, {x: 12, y: 6}, {x: 14, y: 6}, {x: 17, y: 8}
        ];

        function resizeCanvas() {
            const gameContainer = document.querySelector('.game-container');
            const uiPanel = document.querySelector('.ui-panel');
            const availableHeight = gameContainer.clientHeight - uiPanel.offsetHeight - 30;
            const availableWidth = gameContainer.clientWidth - 20;
            TILE_SIZE = Math.floor(Math.min(availableWidth / 20, availableHeight / 12));
            canvas.width = TILE_SIZE * 20;
            canvas.height = TILE_SIZE * 12;
        }

        class Enemy {
            constructor(speed, hp) {
                this.x = -TILE_SIZE;
                this.y = path[0].y * TILE_SIZE + TILE_SIZE / 2;
                this.pathIndex = 0;
                this.speed = speed * (TILE_SIZE / 40);
                this.hp = hp;
                this.maxHp = hp;
            }
            update() {
                if (this.pathIndex >= path.length - 1) {
                    lives--;
                    updateStats();
                    this.hp = 0;
                    if (lives <= 0) gameOver();
                    return;
                }
                const target = path[this.pathIndex + 1];
                const targetX = target.x * TILE_SIZE + TILE_SIZE / 2;
                const targetY = target.y * TILE_SIZE + TILE_SIZE / 2;
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < this.speed) {
                    this.x = targetX; this.y = targetY; this.pathIndex++;
                } else {
                    this.x += (dx / distance) * this.speed; this.y += (dy / distance) * this.speed;
                }
            }
            draw() {
                ctx.fillStyle = '#a0522d';
                ctx.beginPath();
                ctx.arc(this.x, this.y, TILE_SIZE * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#6B8E23';
                ctx.beginPath();
                ctx.arc(this.x, this.y - TILE_SIZE * 0.1, TILE_SIZE * 0.25, 0, Math.PI, true);
                ctx.fill();
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(this.x - TILE_SIZE * 0.4, this.y - TILE_SIZE * 0.6, TILE_SIZE * 0.8, 5);
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(this.x - TILE_SIZE * 0.4, this.y - TILE_SIZE * 0.6, (TILE_SIZE * 0.8) * (this.hp / this.maxHp), 5);
            }
        }
        
        class Tower {
            constructor(x, y, type) {
                this.x = x * TILE_SIZE + TILE_SIZE / 2;
                this.y = y * TILE_SIZE + TILE_SIZE / 2;
                this.type = type;
                this.cooldown = 0;
                this.angle = 0;
                if(type === 'turret') {
                    this.range = TILE_SIZE * 3;
                    this.fireRate = 30;
                    this.projectileSpeed = 7;
                    this.damage = 25;
                } else if (type === 'rocket') {
                    this.range = TILE_SIZE * 4;
                    this.fireRate = 120;
                    this.projectileSpeed = 4;
                    this.damage = 75;
                }
            }
            update() {
                this.cooldown--;
                let target = null;
                let minDistance = this.range;
                for(const enemy of enemies) {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                        target = enemy;
                    }
                }
                if(target) {
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);
                    if (this.cooldown <= 0) {
                        projectiles.push(new Projectile(this.x, this.y, target, this.projectileSpeed, this.damage, this.type));
                        this.cooldown = this.fireRate;
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#6B8E23';
                ctx.beginPath();
                ctx.arc(0, 0, TILE_SIZE * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.rotate(this.angle);
                ctx.fillStyle = '#556B2F';
                if(this.type === 'turret') {
                    ctx.fillRect(0, -TILE_SIZE * 0.1, TILE_SIZE * 0.5, TILE_SIZE * 0.2);
                } else {
                    ctx.fillRect(0, -TILE_SIZE * 0.15, TILE_SIZE * 0.6, TILE_SIZE * 0.3);
                }
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, target, speed, damage, type) {
                this.x = x; this.y = y; this.target = target;
                this.speed = speed * (TILE_SIZE / 40);
                this.damage = damage;
                this.type = type;
            }
            update() {
                if(this.target.hp <= 0) { this.x = -1000; return; }
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < this.speed) {
                    this.target.hp -= this.damage;
                    this.x = -1000;
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }
            draw() {
                ctx.fillStyle = this.type === 'turret' ? '#FFD700' : '#FF4500';
                ctx.beginPath();
                ctx.arc(this.x, this.y, TILE_SIZE * (this.type === 'turret' ? 0.1 : 0.2), 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function spawnWave() {
            wave++;
            waveBonusAwarded = false;
            updateStats();
            let enemyCount = wave * 5, enemyHp = 50 + wave * 25, enemySpeed = 1 + wave * 0.1;
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => { if(gameRunning) enemies.push(new Enemy(enemySpeed, enemyHp)); }, i * 500);
            }
            startWaveBtn.disabled = true;
        }

        function updateStats() {
            scoreEl.textContent = score;
            fundsEl.textContent = funds;
            livesEl.textContent = lives;
            waveEl.textContent = wave;
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawScenery();
            drawPath();
            drawTowerSpots();

            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].update();
                if (enemies[i].hp <= 0) { 
                    funds += 10; 
                    score += 5;
                    updateStats(); 
                    enemies.splice(i, 1); 
                } else { enemies[i].draw(); }
            }
            towers.forEach(t => { t.update(); t.draw(); });
            for (let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].update();
                if (projectiles[i].x < 0) { projectiles.splice(i, 1); } else { projectiles[i].draw(); }
            }
            if (enemies.length === 0 && gameRunning && !waveBonusAwarded) { 
                startWaveBtn.disabled = false;
                score += wave * 25; // Wave bonus
                waveBonusAwarded = true;
                updateStats();
            }
            requestAnimationFrame(gameLoop);
        }
        
        function drawScenery() {
            const baseX = 19 * TILE_SIZE, baseY = 10 * TILE_SIZE;
            ctx.fillStyle = '#6B8E23';
            ctx.fillRect(baseX, baseY, TILE_SIZE * 1.5, TILE_SIZE * 1.5);
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(baseX + TILE_SIZE * 0.2, baseY + TILE_SIZE * 0.2, TILE_SIZE * 1.1, TILE_SIZE * 1.1);
            ctx.fillStyle = '#aaffaa'; // Antenna
            ctx.fillRect(baseX + TILE_SIZE * 0.7, baseY - TILE_SIZE * 0.5, TILE_SIZE * 0.1, TILE_SIZE * 0.5);
            ctx.fillStyle = '#2a2015';
            ctx.beginPath();
            ctx.arc(0, 5.5 * TILE_SIZE, TILE_SIZE * 1.5, -Math.PI / 2, Math.PI / 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, 5.5 * TILE_SIZE, TILE_SIZE * 1.2, -Math.PI / 2, Math.PI / 2);
            ctx.fill();
            drawTree(1, 1);
            drawTree(5, 5);
            drawTree(10, 0);
            drawTree(14, 2);
            drawTree(18, 5);
            drawTree(9, 10);
        }
        
        function drawTree(tileX, tileY) {
            const x = tileX * TILE_SIZE + TILE_SIZE / 2;
            const y = tileY * TILE_SIZE + TILE_SIZE;
            ctx.fillStyle = '#5a4a2f';
            ctx.fillRect(x - TILE_SIZE * 0.1, y - TILE_SIZE * 0.4, TILE_SIZE * 0.2, TILE_SIZE * 0.4);
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y - TILE_SIZE * 0.5, TILE_SIZE * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#3CB371';
            ctx.beginPath();
            ctx.arc(x - TILE_SIZE * 0.2, y - TILE_SIZE * 0.4, TILE_SIZE * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#2E8B57';
            ctx.beginPath();
            ctx.arc(x + TILE_SIZE * 0.2, y - TILE_SIZE * 0.4, TILE_SIZE * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPath() {
            ctx.strokeStyle = '#5a4a2f';
            ctx.lineWidth = TILE_SIZE;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x * TILE_SIZE, path[0].y * TILE_SIZE + TILE_SIZE/2);
            for(let i=0; i < path.length; i++) {
                ctx.lineTo(path[i].x * TILE_SIZE + TILE_SIZE/2, path[i].y * TILE_SIZE + TILE_SIZE/2);
            }
            ctx.lineTo(canvas.width, path[path.length-1].y * TILE_SIZE + TILE_SIZE/2);
            ctx.stroke();
        }
        
        function drawTowerSpots() {
            ctx.fillStyle = "rgba(170, 255, 170, 0.1)";
            towerSpots.forEach(spot => {
                ctx.fillRect(spot.x * TILE_SIZE, spot.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });
        }

        function placeTower(e) {
            if (!selectedTowerType) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
            const spotValid = towerSpots.some(spot => spot.x === x && spot.y === y);
            const spotOccupied = towers.some(t => t.x === x * TILE_SIZE + TILE_SIZE/2 && t.y === y * TILE_SIZE + TILE_SIZE/2);
            if (spotValid && !spotOccupied) {
                let cost = (selectedTowerType === 'turret') ? 100 : 150;
                if (funds >= cost) {
                    funds -= cost;
                    towers.push(new Tower(x, y, selectedTowerType));
                    updateStats();
                }
            }
        }

        function gameOver() {
            gameRunning = false;
            wavesSurvivedEl.textContent = wave;
            finalScoreEl.textContent = score;
            if (score > highScore) {
                highScore = score;
                saveHighScore();
            }
            highScoreEl.textContent = highScore;
            gameOverModal.classList.add('visible');
        }

        function resetGame() {
            funds = 300; lives = 20; wave = 0; score = 0;
            selectedTowerType = null; gameRunning = true; waveBonusAwarded = true;
            towers.length = 0; enemies.length = 0; projectiles.length = 0;
            towerButtons.forEach(b => b.classList.remove('selected'));
            updateStats();
            gameOverModal.classList.remove('visible');
            startWaveBtn.disabled = false;
            gameLoop();
        }
        
        // Firebase Setup
        const firebaseConfig = { apiKey: "AIzaSyA0tfVT75kWle3uwz1HouHRQdEWyzW1YNU", authDomain: "chat-code-forum.firebaseapp.com", projectId: "chat-code-forum", storageBucket: "chat-code-forum.appspot.com", messagingSenderId: "496765673859", appId: "1:496765673859:web:6c2e6695be447d6e32d6b6" };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        async function saveHighScore() {
            if (!userId || !isAuthReady) return;
            const userRef = doc(db, `artifacts/${appId}/users/${userId}/data/tower_defense_game`);
            try { await setDoc(userRef, { highScore: highScore }, { merge: true }); } catch (e) { console.error("Error saving high score:", e); }
        }

        async function loadHighScore() {
            if (!userId || !isAuthReady) return;
            const userRef = doc(db, `artifacts/${appId}/users/${userId}/data/tower_defense_game`);
            try {
                const docSnap = await getDoc(userRef);
                highScore = (docSnap.exists() && docSnap.data().highScore) ? docSnap.data().highScore : 0;
            } catch (e) { console.error("Error loading high score:", e); highScore = 0; }
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                isAuthReady = true;
                await loadHighScore();
            } else {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Firebase Sign-In Failed:", error.code);
                    isAuthReady = true;
                    userId = null;
                }
            }
        });


        window.addEventListener('resize', resizeCanvas);
        startWaveBtn.addEventListener('click', spawnWave);
        canvas.addEventListener('click', placeTower);
        redeployBtn.addEventListener('click', resetGame);
        
        towerButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                towerButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedTowerType = btn.dataset.towerType;
            });
        });

        resetGame();
        gameRunning = false; 
        startWaveBtn.disabled = false;

        resizeCanvas();
        drawScenery();
        drawPath();
        drawTowerSpots();
    });
</script>
</body>
</html>


